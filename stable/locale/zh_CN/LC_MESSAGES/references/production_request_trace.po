# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023-2025, SGLang
# This file is distributed under the same license as the SGLang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SGLang stable\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-09 11:06+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../references/production_request_trace.md:1
msgid "Production Request Tracing"
msgstr ""

#: ../../../references/production_request_trace.md:3
msgid ""
"SGlang exports request trace data based on the OpenTelemetry Collector. You "
"can enable tracing by adding the `--enable-trace` and configure the "
"OpenTelemetry Collector endpoint using `--otlp-traces-endpoint` when "
"launching the server."
msgstr ""

#: ../../../references/production_request_trace.md:5
msgid ""
"You can find example screenshots of the visualization in https://github.com/"
"sgl-project/sglang/issues/8965."
msgstr ""

#: ../../../references/production_request_trace.md:7
msgid "Setup Guide"
msgstr ""

#: ../../../references/production_request_trace.md:8
msgid ""
"This section explains how to configure the request tracing and export the "
"trace data."
msgstr ""

#: ../../../references/production_request_trace.md:9
msgid "Install the required packages and tools"
msgstr ""

#: ../../../references/production_request_trace.md:10
msgid "install Docker and Docker Compose"
msgstr ""

#: ../../../references/production_request_trace.md:11
msgid "install the dependencies"
msgstr ""

#: ../../../references/production_request_trace.md:12
msgid ""
"# enter the SGLang root directory\n"
"pip install -e \"python[tracing]\"\n"
"\n"
"# or manually install the dependencies using pip\n"
"pip install opentelemetry-sdk opentelemetry-api opentelemetry-exporter-otlp "
"opentelemetry-exporter-otlp-proto-grpc\n"
msgstr ""

#: ../../../references/production_request_trace.md:20
msgid "launch opentelemetry collector and jaeger"
msgstr ""

#: ../../../references/production_request_trace.md:21
msgid "docker compose -f examples/monitoring/tracing_compose.yaml up -d\n"
msgstr ""

#: ../../../references/production_request_trace.md:25
msgid "start your SGLang server with tracing enabled"
msgstr ""

#: ../../../references/production_request_trace.md:26
msgid ""
"# set env variables\n"
"export SGLANG_OTLP_EXPORTER_SCHEDULE_DELAY_MILLIS=500\n"
"export SGLANG_OTLP_EXPORTER_MAX_EXPORT_BATCH_SIZE=64\n"
"# start the prefill and decode server\n"
"python -m sglang.launch_server --enable-trace --otlp-traces-endpoint "
"0.0.0.0:4317 <other option>\n"
"# start the mini lb\n"
"python -m sglang_router.launch_router --enable-trace --otlp-traces-endpoint "
"0.0.0.0:4317 <other option>\n"
msgstr ""

#: ../../../references/production_request_trace.md:36
msgid ""
"Replace `0.0.0.0:4317` with the actual endpoint of the opentelemetry "
"collector. If you launched the openTelemetry collector with tracing_compose."
"yaml, the default receiving port is 4317."
msgstr ""

#: ../../../references/production_request_trace.md:38
msgid ""
"To use the HTTP/protobuf span exporter, set the following environment "
"variable and point to an HTTP endpoint, for example, `http://0.0.0.0:4318/v1/"
"traces`."
msgstr ""

#: ../../../references/production_request_trace.md:39
msgid "export OTEL_EXPORTER_OTLP_TRACES_PROTOCOL=http/protobuf\n"
msgstr ""

#: ../../../references/production_request_trace.md:44
msgid "raise some requests"
msgstr ""

#: ../../../references/production_request_trace.md:45
msgid "Observe whether trace data is being exported"
msgstr ""

#: ../../../references/production_request_trace.md:46
msgid ""
"Access port 16686 of Jaeger using a web browser to visualize the request "
"traces."
msgstr ""

#: ../../../references/production_request_trace.md:47
msgid ""
"The OpenTelemetry Collector also exports trace data in JSON format to /tmp/"
"otel_trace.json. In a follow-up patch, we will provide a tool to convert "
"this data into a Perfetto-compatible format, enabling visualization of "
"requests in the Perfetto UI."
msgstr ""

#: ../../../references/production_request_trace.md:49
msgid "How to add Tracing for slices you're interested in?"
msgstr ""

#: ../../../references/production_request_trace.md:50
msgid ""
"We have already inserted instrumentation points in the tokenizer and "
"scheduler main threads. If you wish to trace additional request execution "
"segments or perform finer-grained tracing, please use the APIs from the "
"tracing package as described below."
msgstr ""

#: ../../../references/production_request_trace.md:52
msgid "initialization"
msgstr ""

#: ../../../references/production_request_trace.md:54
msgid ""
"Every process involved in tracing during the initialization phase should "
"execute:"
msgstr ""

#: ../../../references/production_request_trace.md:55
msgid "process_tracing_init(otlp_traces_endpoint, server_name)\n"
msgstr ""

#: ../../../references/production_request_trace.md:58
msgid ""
"The otlp_traces_endpoint is obtained from the arguments, and you can set "
"server_name freely, but it should remain consistent across all processes."
msgstr ""

#: ../../../references/production_request_trace.md:60
msgid ""
"Every thread involved in tracing during the initialization phase should "
"execute:"
msgstr ""

#: ../../../references/production_request_trace.md:61
msgid "trace_set_thread_info(\"thread label\", tp_rank, dp_rank)\n"
msgstr ""

#: ../../../references/production_request_trace.md:64
msgid ""
"The \"thread label\" can be regarded as the name of the thread, used to "
"distinguish different threads in the visualization view."
msgstr ""

#: ../../../references/production_request_trace.md:66
msgid "Mark the beginning and end of a request"
msgstr ""

#: ../../../references/production_request_trace.md:67
msgid ""
"trace_req_start(rid, bootstrap_room)\n"
"trace_req_finish(rid)\n"
msgstr ""

#: ../../../references/production_request_trace.md:71
msgid ""
"These two APIs must be called within the same process, for example, in the "
"tokenizer."
msgstr ""

#: ../../../references/production_request_trace.md:73
msgid "Add tracing for slice"
msgstr ""

#: ../../../references/production_request_trace.md:75
msgid "Add slice tracing normally:"
msgstr ""

#: ../../../references/production_request_trace.md:76
msgid ""
"trace_slice_start(\"slice A\", rid)\n"
"trace_slice_end(\"slice A\", rid)\n"
msgstr ""

#: ../../../references/production_request_trace.md:81
msgid ""
"Use the \"anonymous\" flag to not specify a slice name at the start of the "
"slice, allowing the slice name to be determined by trace_slice_end. "
"<br>Note: Anonymous slices must not be nested."
msgstr ""

#: ../../../references/production_request_trace.md:81
msgid "<br>"
msgstr ""

#: ../../../references/production_request_trace.md:83
msgid ""
"trace_slice_start(\"\", rid, anonymous = True)\n"
"trace_slice_end(\"slice A\", rid)\n"
msgstr ""

#: ../../../references/production_request_trace.md:88
msgid ""
"In trace_slice_end, use auto_next_anon to automatically create the next "
"anonymous slice, which can reduce the number of instrumentation points "
"needed."
msgstr ""

#: ../../../references/production_request_trace.md:89
msgid ""
"trace_slice_start(\"\", rid, anonymous = True)\n"
"trace_slice_end(\"slice A\", rid, auto_next_anon = True)\n"
"trace_slice_end(\"slice B\", rid, auto_next_anon = True)\n"
"trace_slice_end(\"slice C\", rid, auto_next_anon = True)\n"
"trace_slice_end(\"slice D\", rid)\n"
msgstr ""

#: ../../../references/production_request_trace.md:96
msgid ""
"The end of the last slice in a thread must be marked with "
"thread_finish_flag=True; otherwise, the thread's span will not be properly "
"generated."
msgstr ""

#: ../../../references/production_request_trace.md:97
msgid "trace_slice_end(\"slice D\", rid, thread_finish_flag = True)\n"
msgstr ""

#: ../../../references/production_request_trace.md:101
msgid ""
"When the request execution flow transfers to another thread, the trace "
"context needs to be explicitly propagated."
msgstr ""

#: ../../../references/production_request_trace.md:102
msgid ""
"sender: Execute the following code before sending the request to another "
"thread via ZMQ"
msgstr ""

#: ../../../references/production_request_trace.md:103
msgid ""
"trace_context = trace_get_proc_propagate_context(rid)\n"
"req.trace_context = trace_context\n"
msgstr ""

#: ../../../references/production_request_trace.md:107
msgid ""
"receiver: Execute the following code after receiving the request via ZMQ"
msgstr ""

#: ../../../references/production_request_trace.md:108
msgid "trace_set_proc_propagate_context(rid, req.trace_context)\n"
msgstr ""

#: ../../../references/production_request_trace.md:112
msgid ""
"When the request execution flow transfers to another node(PD "
"disaggregation), the trace context needs to be explicitly propagated."
msgstr ""

#: ../../../references/production_request_trace.md:113
msgid ""
"sender: Execute the following code before sending the request to node thread "
"via http"
msgstr ""

#: ../../../references/production_request_trace.md:114
msgid ""
"trace_context = trace_get_remote_propagate_context(bootstrap_room_list)\n"
"headers = {\"trace_context\": trace_context}\n"
"session.post(url, headers=headers)\n"
msgstr ""

#: ../../../references/production_request_trace.md:119
msgid ""
"receiver: Execute the following code after receiving the request via http"
msgstr ""

#: ../../../references/production_request_trace.md:120
msgid "trace_set_remote_propagate_context(request.headers['trace_context'])\n"
msgstr ""

#: ../../../references/production_request_trace.md:124
msgid ""
"How to Extend the Tracing Framework to Support Complex Tracing Scenarios"
msgstr ""

#: ../../../references/production_request_trace.md:126
msgid ""
"The currently provided tracing package still has potential for further "
"development. If you wish to build more advanced features upon it, you must "
"first understand its existing design principles."
msgstr ""

#: ../../../references/production_request_trace.md:128
msgid ""
"The core of the tracing framework's implementation lies in the design of the "
"span structure and the trace context. To aggregate scattered slices and "
"enable concurrent tracking of multiple requests, we have designed a two-"
"level trace context structure and a four-level span structure: "
"`SglangTraceReqContext`, `SglangTraceThreadContext`. Their relationship is "
"as follows:"
msgstr ""

#: ../../../references/production_request_trace.md:129
msgid ""
"SglangTraceReqContext (req_id=\"req-123\")\n"
"├── SglangTraceThreadContext(thread_label=\"scheduler\", tp_rank=0)\n"
"|\n"
"└── SglangTraceThreadContext(thread_label=\"scheduler\", tp_rank=1)\n"
msgstr ""

#: ../../../references/production_request_trace.md:136
msgid ""
"Each traced request maintains a global `SglangTraceReqContext`. For every "
"thread processing the request, a corresponding `SglangTraceThreadContext` is "
"recorded and composed within the `SglangTraceReqContext`. Within each "
"thread, every currently traced slice (possibly nested) is stored in a list."
msgstr ""

#: ../../../references/production_request_trace.md:138
msgid ""
"In addition to the above hierarchy, each slice also records its previous "
"slice via Span.add_link(), which can be used to trace the execution flow."
msgstr ""

#: ../../../references/production_request_trace.md:140
msgid ""
"When the request execution flow transfers to a new thread, the trace context "
"needs to be explicitly propagated. In the framework, this is represented by "
"`SglangTracePropagateContext`, which contains the context of the request "
"span and the previous slice span."
msgstr ""

#: ../../../references/production_request_trace.md:143
msgid ""
"We designed a four-level span structure, consisting of "
"`bootstrap_room_span`, `req_root_span`, `thread_span`, and `slice_span`. "
"Among them, `req_root_span` and `thread_span` correspond to "
"`SglangTraceReqContext` and `SglangTraceThreadContext`, respectively, and "
"`slice_span` is stored within the `SglangTraceThreadContext`. The "
"`bootstrap_room_span` is designed to accommodate the separation of PD-"
"disaggregation. On different nodes, we may want to add certain attributes to "
"the `req_root_span`. However, if the `req_root_span` is shared across all "
"nodes, the Prefill and Decode nodes would not be allowed to add attributes "
"due to the constraints imposed by OpenTelemetry's design."
msgstr ""

#: ../../../references/production_request_trace.md:145
msgid ""
"bootstrap room span\n"
"├── router req root span\n"
"|    └── router thread span\n"
"|          └── slice span\n"
"├── prefill req root span\n"
"|    ├── tokenizer thread span\n"
"|    |     └── slice span\n"
"|    └── scheduler thread span\n"
"|          └── slice span\n"
"└── decode req root span\n"
"      ├── tokenizer thread span\n"
"      |    └── slice span\n"
"      └── scheduler thread span\n"
"           └── slice span\n"
msgstr ""
